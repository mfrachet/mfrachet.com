---
title: "Astro: progressively enhanced forms"
date: 2023-11-07
---

From [MDN documentation](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement):

> Progressive enhancement is a design philosophy that provides a baseline of essential content and functionality to as many users as possible, while delivering the best possible experience only to users of the most modern browsers that can run all the required code.

One great example of progressive enhancement is form handling in [Remix](https://remix.run/).

In Remix, you can create an almost regular HTML form, a function named `action` exported from the route module and there you go: the form is working **with and without JavaScript**.
It means that people disabling JavaScript in their browser, or people under specific constraints regarding their devices (or browsers, or low-connectivity regions) can still use the form and benefit from the feature.

Some people can stand that it's probably not necessary, and I agree. The thing is you have it for free. It's baked in and works using the same API no matter you submit the form from JavaScript or from the HTML form itself.

```tsx
// Copy/pasted from the Remix doc
// about action https://remix.run/docs/en/main/route/action
export async function action({ request }: ActionFunctionArgs) {
  const body = await request.formData();
  const title = body.get("title");
  const todo = await fakeCreateTodo({ title });

  return redirect(`/todos/${todo.id}`);
}

export default function AddTodo() {
  return (
    <Form method="post">
      <input type="text" name="title" />
      <button type="submit">Create Todo</button>
    </Form>
  );
}
```

It's a minimal API that provides a great experience to the users.

## Remix is great, but what about [Astro](https://astro.build/)?

As you may already know, Astro is a framework for server side rendering that provides the ability to integrate frontend frameworks to get interactivity in the client. It is not the same kind of (meta) framework than [Remix](https://remix.run/) or [Nextjs](https://nextjs.org/).
And as pointed on [their homepage](https://astro.build/), the framework focuses on content websites _for now_.

Basically, regarding froms, it means: use regular HTML forms or the things you have available on your client side framework (e.g: [formik](https://formik.org/) on React, or whatever alternative), or build something yourself.

We are going to try building something as close to what Remix provides as possible knowing that we have the following constraint: we only build user-lands, we can't tweak the inner framework implementation.

It's important to have that in mind. We'll be forced to add a bit of verbosity along the way.

## Let's get into it

I assume you already have an Astro project running locally. If that's not the case, you can create one from [the get started page](https://docs.astro.build/en/getting-started/).

### Create an HTML form

The first step is to create a regular HTML form that we will enhance later:

```astro
---
// index.astro
---
<main>
  <h1>Welcome</h1>
  <form method="post">
    <label>
      Email
      <input type="email" name="email" />
    </label>

    <label>
      Password
      <input type="password" name="password" />
    </label>

    <button>Sign in</button>
  </form>
</main>
```

### Handle the form on the backend

This will be the progressive enhancement "baseline": a form that works with regular HTML, validated and handled in the backend so that as many users as possible can use it.

Additional note: this works without JavaScript on the client.

```astro
---
// index.astro

let error: string | undefined;

if (Astro.request.method === "POST") {
  // process form handling
  const data = await Astro.request.formData();
  const email = data.get("email")?.toString() || "";
  const password = data.get("email")?.toString() || "";

  // basic email verifications
  if (!email.includes("@domain.com")) {
    error = "Invalid email. It should contain @domain.com";
  }
}
---
<main>
  <h1>Welcome</h1>
  {error && <span>{error}</span>}
  <!-- HTML markup for the form -->
</main>
```

### Handling the form client side

The form works great but the page is flashing: when we submit the form, we make an HTTP POST request and get back an HTTP response which is basically a new, whole, document. The browser refreshes and it creates an effect of flickering.

We can mitigate this default behaviour by adding JavaScript on the client and instead of making a regular HTTP request, we can make a `fetch` one instead without refreshing the page.

### Enhancing the form client side

In this post, we'll create a framework agnostic solution.

```astro
---
// index.astro
// The POST handling server side
---
<main>
  <h1>Welcome</h1>
  {error && <span>{error}</span>}
  <!-- HTML markup for the form -->
</main>

<script>
  // Get the form reference
  const form = document.querySelector("form");

  if (form) {
    // listen to the submit event of the form
    form.addEventListener("submit", function (e) {
      // Avoid to page flickering and deal with the form client side
      e.preventDefault();

      // fetch the current route instead of using the HTML form submission
      fetch(form.action, {
        method: form.method,
        body: new FormData(form),
        headers: {
          accept: "application/json",
        },
      }).then((res) => res.json());
    });
  }
</script>
```

At this point, if you try to submit the form, the page does not refresh anymore. If you check the `network` tab of your browsers devtools, you should see a POST request hitting your current route but resolving a `document`.

Since we are already in the browser, we don't want to receive a complete document. It wouldn't make sense since we would be in the same situation as before. What we want is JSON data that we can use to update the UI.

To achieve that, we need to modify the form handling on the server to return JSON in one case and a whole document in another case:

```astro
---
let error: string | undefined;

if (Astro.request.method === "POST") {
  const data = await Astro.request.formData();
  const email = data.get("email")?.toString() || "";
  const password = data.get("email")?.toString() || "";

  if (!email.includes("@domain.com")) {
    error = "Invalid email. It should contain @domain.com";
  }

  // Verify if the request comes from the client or the server
  const isClientRequest =
    Astro.request.headers.get("accept") === "application/json";

  // If it comes from the client, return a JSON response with the data
  if (isClientRequest) {
    const response = new Response(JSON.stringify({ error }));

    return response;
  }
}
---
```

If you now try to submit the form again with JavaScript enabled, with your devtools opened, you can see that the fetch request now returns a JSON object with the error. It means that we can deal with this object to update the UI.

### Cleaning up the ground and abstracting

It's already a bunch of code. Let's try to abstract the code from both the client and the server so that we can use it in different places easily.

#### On the client

On the browser, what we want is something as easy as:

```astro
<script>
  import { handleClientForm } from "./handleClientForm";

  handleClientForm(document.querySelector("form"));
</script>

```

We can achieve this by moving most of the `<script>` tag into a dedicated `handleClientForm` function:

```ts
export const handleClientForm = (form?: HTMLFormElement | null) => {
  if (!form) return;

  // listen to the submit event of the form
  form.addEventListener("submit", function (e) {
    // Avoid to page flickering and deal with the form client side
    e.preventDefault();

    // fetch the current route instead of using the HTML form submission
    fetch(form.action, {
      method: form.method,
      body: new FormData(form),
      headers: {
        accept: "application/json",
      },
    }).then((res) => res.json());
  });
};
```

#### On the server

Same goes for the server: the idea is to move things in a dedicated `action` function to try getting as close as possible to what Remix does:

```ts
import type { AstroGlobal } from "astro";

export type ActionReturnType<T> = Promise<{
  response?: Response;
  data?: T;
}>;

export type CallbackAction<T> = () => Promise<T>;

export const action = async <T>(
  Astro: AstroGlobal,
  actionFn: CallbackAction<T>
): ActionReturnType<T> => {
  if (Astro.request.method === "POST") {
    const isClientRequest =
      Astro.request.headers.get("accept") === "application/json";

    // We have moved the Astro.request.formData() computations
    // outside this action function. This form checking
    // should now be done in the callback
    const data: T = await actionFn({ request: Astro.request });

    if (isClientRequest) {
      const response = new Response(JSON.stringify(data));

      return { response, data };
    }

    return { data };
  }

  return { data: undefined };
};
```

Here is how we would use it into the page module:

```ts
const { data, response } = await action(Astro, async () => {
  const data = await Astro.request.formData();
  const email = data.get("email")?.toString() || "";
  const password = data.get("email")?.toString() || "";

  if (!email.includes("@domain.com")) {
    return { error: "Invalid email. It should contain @domain.com" };
  }
});

if (response) return response;
```

The `action` function returns two objects: a `data` one and a `response` one.

- When we submit the form using the regular HTTP way, we got back an entire document that is computed by astro with the variable available: in this case, it will use `data` to populate the template and since `data.error` might be filled, the template is generated accordingly.
- When we submit the form using JavaScript on the client, we got back a JSON object. We don't want Astro to generate a whole HTML document and so we shortcut the Astro request with the `return response`.

This is the limitation I was referring too when saying that we will now exactly do what remix does. Remix has control over the route themselves and wraps them under the hood which is something we can't do user-lands with Astro.
