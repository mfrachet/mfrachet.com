---
title: "Astro: progressively enhanced forms"
date: 2023-11-07
---

From [MDN documentation](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement):

> Progressive enhancement is a design philosophy that provides a baseline of essential content and functionality to as many users as possible, while delivering the best possible experience only to users of the most modern browsers that can run all the required code.

One great example of progressive enhancement is form handling in [Remix](https://remix.run/).

In Remix, you can create an almost regular HTML form, a function named `action` exported from the route module and there you go: the form is working **with and without JavaScript**.
It means that people disabling JavaScript in their browser, or people under specific constraints regarding their devices (or browsers, or low-connectivity regions) can still use the form and benefit from the feature.

Some people can stand that it's probably not necessary, and I agree. The thing is you have it for free. It's baked in and works using the same API no matter you submit the form from JavaScript or from the HTML form itself.

```tsx
// Copy/pasted from the Remix doc
// about action https://remix.run/docs/en/main/route/action
export async function action({ request }: ActionFunctionArgs) {
  const body = await request.formData();
  const title = body.get("title");
  const todo = await fakeCreateTodo({ title });

  return redirect(`/todos/${todo.id}`);
}

export default function AddTodo() {
  return (
    <Form method="post">
      <input type="text" name="title" />
      <button type="submit">Create Todo</button>
    </Form>
  );
}
```

It's a minimal API that provides a great experience to the users.

## Remix is great, but what about [Astro](https://astro.build/)?

As you may already know, Astro is a framework for server side rendering that provides the ability to integrate frontend frameworks to get interactivity in the client. It is not the same kind of (meta) framework than [Remix](https://remix.run/) or [Nextjs](https://nextjs.org/).
And as pointed on [their homepage](https://astro.build/), the framework focuses on content websites _for now_.

Basically, regarding froms, it means: use regular HTML forms or the things you have available on your client side framework (e.g: [formik](https://formik.org/) on React, or whatever alternative), or build something yourself.

We are going to try building something as close to what Remix provides as possible knowing that we have the following constraint: we only build user-lands, we can't tweak the inner framework implementation.

It's important to have that in mind. We'll be forced to add a bit of verbosity along the way.

## Let's get into it

I assume you already have an Astro project running locally. If that's not the case, you can create one from [the get started page](https://docs.astro.build/en/getting-started/).

### Create an HTML form

The first step is to create a regular HTML form that we will enhance later:

```astro
---
// index.astro
---
<main>
  <h1>Welcome</h1>
  <form method="post">
    <label>
      Email
      <input type="email" name="email" />
    </label>

    <label>
      Password
      <input type="password" name="password" />
    </label>

    <button>Sign in</button>
  </form>
</main>
```

### Handle the form on the backend

This will be the progressive enhancement "baseline": a form that works with regular HTML, validated and handled in the backend so that as many users as possible can use it.

Additional note: this works without JavaScript on the client.

```astro
---
// index.astro

let error: string | undefined;

if (Astro.request.method === "POST") {
  // process form handling
  const data = await Astro.request.formData();
  const email = data.get("email")?.toString() || "";
  const password = data.get("email")?.toString() || "";

  // basic email verifications
  if (!email.includes("@domain.com")) {
    error = "Invalid email. It should contain @domain.com";
  }
}
---
<main>
  <h1>Welcome</h1>
  {error && <span>{error}</span>}
  <!-- HTML markup for the form -->
</main>
```

### Handling the form client side

The form works great but the page is flashing: when we submit the form, we make an HTTP POST request and get back an HTTP response which is basically a new, whole, document. The browser refreshes and it creates an effect of flickering.

We can mitigate this default behaviour by adding JavaScript on the client and instead of making a regular HTTP request, we can make a `fetch` one instead without refreshing the page.

### Enhancing the form client side

In this post, we'll create a framework agnostic solution.

```astro
---
// index.astro
// The POST handling server side
---
<main>
  <h1>Welcome</h1>
  {error && <span>{error}</span>}
  <!-- HTML markup for the form -->
</main>

<script>
  // Get the form reference
  const form = document.querySelector("form");

  if (form) {
    // listen to the submit event of the form
    form.addEventListener("submit", function (e) {
      // Avoid to page flickering and deal with the form client side
      e.preventDefault();

      // fetch the current route instead of using the HTML form submission
      fetch(form.action, {
        method: form.method,
        body: new FormData(form),
        headers: {
          accept: "application/json",
        },
      }).then((res) => res.json());
    });
  }
</script>
```

At this point, if you try to submit the form, the page does not refresh anymore. If you check the `network` tab of your browsers devtools, you should see a POST request hitting your current route but resolving a `document`.

Since we are already in the browser, we don't want to receive a complete document. It wouldn't make sense since we would be in the same situation as before. What we want is JSON data that we can use to update the UI.
